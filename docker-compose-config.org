#+title: Docker Compose Configuration
#+author: Matthew Wells


* Configure our docker compose setup

** .env
Generate an environment configuration file

#+begin_src elisp :results silent file :file (concat org-my-project-root ".env")
  (let ((vars '()))
    (dolist (key-readfn
             '(("MYSQL_PASSWORD=" . read-passwd)
               ("MYSQL_ROOT_PASSWORD=" . read-passwd)
               ("MYSQL_DATABASE=" . read-string)
               ("MYSQL_USER=" . read-string)
               ("VIRTUAL_HOST=" . read-string)
               ("LETSENCRYPT_HOST=" . read-string)
               ("LETSENCRYPT_EMAIL=" . read-string))
             vars)
      (let ((key (car key-readfn))
            (fn (cdr key-readfn)))
        (add-to-list 'vars (concat key (funcall fn key)) t)))
    (string-join vars "\n"))
#+end_src

** docker-compose.yml
Place the docker-compose file in position on the remote server
#+begin_src yaml :tangle (concat org-my-project-root "docker-compose.yml")
  services:
    db:
      image: mariadb:11.4
      command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW
      restart: always
      volumes:
        - db:/var/lib/mysql
      env_file:
        - .env

    redis:
      image: redis:alpine
      restart: always

    app:
      image: nextcloud:32-fpm-alpine
      restart: always
      volumes:
        - nextcloud:/var/www/html
        - ${PWD}/backups:/tmp/backups
      environment:
        - MYSQL_HOST=db
        - REDIS_HOST=redis
      env_file:
        - .env
      depends_on:
        - db
        - redis

    web:
      image: nginx:alpine-slim
      restart: always
      volumes:
        - ./web/nginx.conf:/etc/nginx/nginx.conf:ro
        - nextcloud:/var/www/html:z,ro
      env_file:
        - .env
      depends_on:
        - app
      networks:
        - proxy-tier
        - default

    cron:
      image: nextcloud:32-fpm-alpine
      restart: always
      volumes:
        - nextcloud:/var/www/html
      entrypoint: /cron.sh
      env_file:
        - .env
      depends_on:
        - db
        - redis

    proxy:
      build: ./proxy
      restart: always
      ports:
        - 80:80
        - 443:443
      labels:
        com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy: "true"
      volumes:
        - certs:/etc/nginx/certs:ro
        - vhost.d:/etc/nginx/vhost.d
        - html:/usr/share/nginx/html
        - /var/run/docker.sock:/tmp/docker.sock:ro
      networks:
        - proxy-tier

    letsencrypt-companion:
      image: jrcs/letsencrypt-nginx-proxy-companion
      restart: always
      volumes:
        - acme:/etc/acme.sh
        - certs:/etc/nginx/certs
        - vhost.d:/etc/nginx/vhost.d
        - html:/usr/share/nginx/html
        - /var/run/docker.sock:/var/run/docker.sock:ro
      networks:
        - proxy-tier
      depends_on:
        - proxy

  volumes:
    db:
    nextcloud:
    acme:
    certs:
    vhost.d:
    html:

  networks:
    proxy-tier:

#+end_src

** Proxy container

Generate the dockerfile and configuration for the proxy container
#+begin_src Dockerfile :tangle (concat org-my-project-root "proxy/Dockerfile") :mkdirp yes
FROM jwilder/nginx-proxy:alpine
COPY uploadsize.conf /etc/nginx/conf.d/uploadsize.conf
#+end_src

#+begin_src conf :tangle (concat org-my-project-root "proxy/uploadsize.conf") :mkdirp yes
client_max_body_size 1G;
proxy_request_buffering off;
#+end_src

** Web container

Generate configuration for the web container

#+begin_src conf :tangle (concat org-my-project-root "web/nginx.conf") :mkdirp yes
  worker_processes auto;

  error_log  /var/log/nginx/error.log warn;
  pid        /var/run/nginx.pid;


  events {
      worker_connections  1024;
  }


  http {
      include mime.types;
      default_type  application/octet-stream;
      types {
          text/javascript mjs;
          application/wasm wasm;
      }

      log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';

      access_log  /var/log/nginx/access.log  main;

      sendfile        on;
      #tcp_nopush     on;

      # Prevent nginx HTTP Server Detection
      server_tokens   off;

      keepalive_timeout  65;

      # Set the `immutable` cache control options only for assets with a cache busting `v` argument
      map $arg_v $asset_immutable {
          "" "";
      default ", immutable";
      }

      #gzip  on;

      upstream php-handler {
          server app:9000;
      }

      server {
          listen 80;

          # HSTS settings
          # WARNING: Only add the preload option once you read about
          # the consequences in https://hstspreload.org/. This option
          # will add the domain to a hardcoded list that is shipped
          # in all major browsers and getting removed from this list
          # could take several months.
          #add_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload;" always;

          # set max upload size and increase upload timeout:
          client_max_body_size 1G;
          client_body_timeout 300s;
          fastcgi_buffers 64 4K;

          # The settings allows you to optimize the HTTP2 bandwidth.
          # See https://blog.cloudflare.com/delivering-http-2-upload-speed-improvements/
          # for tuning hints
          client_body_buffer_size 512k;

          # Enable gzip but do not remove ETag headers
          gzip on;
          gzip_vary on;
          gzip_comp_level 4;
          gzip_min_length 256;
          gzip_proxied expired no-cache no-store private no_last_modified no_etag auth;
          gzip_types application/atom+xml text/javascript application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/wasm application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy;

          # Pagespeed is not supported by Nextcloud, so if your server is built
          # with the `ngx_pagespeed` module, uncomment this line to disable it.
          #pagespeed off;

          # HTTP response headers borrowed from Nextcloud `.htaccess`
          add_header Referrer-Policy                      "no-referrer"       always;
          add_header X-Content-Type-Options               "nosniff"           always;
          add_header X-Frame-Options                      "SAMEORIGIN"        always;
          add_header X-Permitted-Cross-Domain-Policies    "none"              always;
          add_header X-Robots-Tag                         "noindex, nofollow" always;
          add_header X-XSS-Protection                     "1; mode=block"     always;

          # Remove X-Powered-By, which is an information leak
          fastcgi_hide_header X-Powered-By;

          # Path to the root of your installation
          root /var/www/html;

          # Specify how to handle directories -- specifying `/index.php$request_uri`
          # here as the fallback means that Nginx always exhibits the desired behaviour
          # when a client requests a path that corresponds to a directory that exists
          # on the server. In particular, if that directory contains an index.php file,
          # that file is correctly served; if it doesn't, then the request is passed to
          # the front-end controller. This consistent behaviour means that we don't need
          # to specify custom rules for certain paths (e.g. images and other assets,
          # `/updater`, `/ocm-provider`, `/ocs-provider`), and thus
          # `try_files $uri $uri/ /index.php$request_uri`
          # always provides the desired behaviour.
          index index.php index.html /index.php$request_uri;

          # Rule borrowed from `.htaccess` to handle Microsoft DAV clients
          location = / {
              if ( $http_user_agent ~ ^DavClnt ) {
                  return 302 /remote.php/webdav/$is_args$args;
              }
          }

          location = /robots.txt {
              allow all;
              log_not_found off;
              access_log off;
          }

          # Make a regex exception for `/.well-known` so that clients can still
          # access it despite the existence of the regex rule
          # `location ~ /(\.|autotest|...)` which would otherwise handle requests
          # for `/.well-known`.
          location ^~ /.well-known {
              # The rules in this block are an adaptation of the rules
              # in `.htaccess` that concern `/.well-known`.

              location = /.well-known/carddav { return 301 /remote.php/dav/; }
              location = /.well-known/caldav  { return 301 /remote.php/dav/; }

              location /.well-known/acme-challenge    { try_files $uri $uri/ =404; }
              location /.well-known/pki-validation    { try_files $uri $uri/ =404; }

              # Let Nextcloud's API for `/.well-known` URIs handle all other
              # requests by passing them to the front-end controller.
              return 301 /index.php$request_uri;
          }

          # Rules borrowed from `.htaccess` to hide certain paths from clients
          location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)(?:$|/)  { return 404; }
          location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console)                { return 404; }

          # Ensure this block, which passes PHP files to the PHP process, is above the blocks
          # which handle static assets (as seen below). If this block is not declared first,
          # then Nginx will encounter an infinite rewriting loop when it prepends `/index.php`
          # to the URI, resulting in a HTTP 500 error response.
          location ~ \.php(?:$|/) {
              # Required for legacy support
              rewrite ^/(?!index|remote|public|cron|core\/ajax\/update|status|ocs\/v[12]|updater\/.+|ocs-provider\/.+|.+\/richdocumentscode(_arm64)?\/proxy) /index.php$request_uri;

              fastcgi_split_path_info ^(.+?\.php)(/.*)$;
              set $path_info $fastcgi_path_info;

              try_files $fastcgi_script_name =404;

              include fastcgi_params;
              fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
              fastcgi_param PATH_INFO $path_info;
              fastcgi_param HTTPS on;

              fastcgi_param modHeadersAvailable true;         # Avoid sending the security headers twice
              fastcgi_param front_controller_active true;     # Enable pretty urls
              fastcgi_pass php-handler;

              fastcgi_intercept_errors on;
              fastcgi_request_buffering off;

              fastcgi_max_temp_file_size 0;
          }

          # Serve static files
          location ~ \.(?:css|js|mjs|svg|gif|ico|jpg|png|webp|wasm|tflite|map|ogg|flac)$ {
              try_files $uri /index.php$request_uri;
              add_header Cache-Control "public, max-age=15778463$asset_immutable";
              add_header Referrer-Policy                   "no-referrer"       always;
              add_header X-Content-Type-Options            "nosniff"           always;
              add_header X-Frame-Options                   "SAMEORIGIN"        always;
              add_header X-Permitted-Cross-Domain-Policies "none"              always;
              add_header X-Robots-Tag                      "noindex, nofollow" always;
              add_header X-XSS-Protection                  "1; mode=block"     always;
              access_log off;     # Optional: Don't log access to assets

              location ~ \.wasm$ {
                  default_type application/wasm;
              }
          }

          location ~ \.(otf|woff2?)$ {
              try_files $uri /index.php$request_uri;
              expires 7d;         # Cache-Control policy borrowed from `.htaccess`
              access_log off;     # Optional: Don't log access to assets
          }

          # Rule borrowed from `.htaccess`
          location /remote {
              return 301 /remote.php$request_uri;
          }

          location / {
              try_files $uri $uri/ /index.php$request_uri;
          }
      }
  }
#+end_src


* Run Services

** Check Services Status

View container status
#+begin_src eshell :results silent output :dir (concat org-my-project-root "")
  docker compose --no-ansi ps
#+end_src

** Start Services
Start all the containers

#+begin_src eshell :results silent output :dir org-my-project-root
  docker compose --no-ansi up -d
#+end_src

** Stop Services
Stop all the containers

#+begin_src eshell :results silent output :dir (concat org-my-project-root "")
  docker compose --no-ansi stop
#+end_src

** Update Services

Get new versions of the containers
#+begin_src eshell :results silent output :dir (concat org-my-project-root "")
  docker compose --no-ansi pull
#+end_src

** Check Logs

Get a tail of the previous 50 log entries

#+begin_src shell :results silent output :dir (concat org-my-project-root "")
  docker compose --no-ansi logs --tail 50 web
#+end_src



